# 工厂模式

无法识别对象

# 构造函数模式

与工厂模式不同：

* 没有显示创建对象
* 直接将属性和方法赋给this
* 没有return

new过程：

* 创建一个新对象
* 将构造函数的作用域赋给新对象
* 执行构造函数中的代码
* 返回新对象

可以使用constructor属性和instance of来检测对象类型

#### 将构造函数作为函数

构造函数  
普通函数 window  
在另一个对象作用域使用  call、apply等

#### 构造函数的问题

每个方法都要重新创建一遍

# 原型模式

每个函数都有一个property属性，指向一个对象，对象包含由特定类型的所有实例共享的属性和方法

#### 理解原型对象

* 创建函数时会创建property属性指向原型对象，原型对象会有一个constructor属性指向property属性所在的函数，Person.property.constructor指向Person
* 每个函数的实例内部有个指针指向原型对象，在Firefox、Safari、和Chrome中可以通过\_\_proto\_\_来访问
* 可以用isPropertyOf方法来测试\_\_proto\_\_的指向
* Object.getPropertyOf可以获得对象的原型
* 搜索属性现在实例中搜索，没有到原型对象中搜索
* 为对象添加属性会屏蔽原型中的同名属性，使用delete删除实例属性之后可以重新访问
* hasOwnProperty检测属性是否存在于实例中

#### 原型和in操作符

单独使用和在for-in中使用

* 单独使用：在对象能够访问给定属性是返回true，无论在实例中还是原型中，可以通过in和hasOwnProperty来检测属性在实例中还是原型中
* for-in循环：返回可访问的、可枚举的属性，既包括实例属性又包括原型属性。屏蔽了原型中不可枚举属性的实力属性也会返回，所有开发人员定义的属性都是可枚举的。
* Object.keys获取对象上可枚举的实例属性。
* Object.getOwnPropertyNames获取所有实例属性，无论是否可枚举

#### 更简单的原型语法

使用一个包含所有属性和方法的对象字面量来重写原型对象，但是此时原型链会断开，constructor指向了Object，可以通过重新指定constructor的值重新连接，但是会导致constructor可枚举，可以通过Object.defineProperty设置

#### 原型的动态性

对原型所做的任何修改都能立即从实例上反映出来  
使用对象字面量创建实例会切断现有实例和原型的联系

#### 原生对象的原型

可以通过原生对象的原型为原生对象定义新方法

#### 原型对象问题

* 省略了构造函数传递初始化参数环节，所有实例默认取得相同的属性值
* 修改一个实例的属性会导致其他实例的属性也发生改变

# 组合使用构造函数模式和原型模式

构造函数模式定义实例属性，原型模式定义方法和共享的属性

# 动态原型模式

通过检查某个应该存在的方法是否有效来决定是否初始化原型

# 寄生构造函数模式

创建一个函数封装创建对象的代码，再返回一个对象。除了使用new操作符并把包装函数叫做构造函数其他和工厂模式一样。  
可以在特殊情况下为对象创建构造函数。比如创建一个有额外方法的特殊数组。返回的对象与构造函数或者构造函数的原型之间没有关系，不能用instance of 来确定对象类型。

**可以对push方法使用apply直接在数组末尾添加一个数组**

# 稳妥构造函数模式

与寄生构造函数类似，但是创建对象实例方法时不使用this，也不实用new操作符调用构造函数。

